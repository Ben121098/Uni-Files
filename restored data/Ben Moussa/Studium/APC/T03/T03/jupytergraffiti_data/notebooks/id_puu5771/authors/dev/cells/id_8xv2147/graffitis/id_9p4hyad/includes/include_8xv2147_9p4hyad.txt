# Defining number of steps 
N_sim = int(60/step_size)

# matrices to store the states 
x_data = [x0]
x_hat_data = [x0_observer]
y_measured = []

for i in range(N_sim):
    # Gaussian noise added to the process and the measurements
    w_x = np.random.normal(0, np.sqrt(var_x), nx).reshape(nx, 1)
    w_y = np.random.normal(0, np.sqrt(var_y), ny).reshape(ny, 1)

    # Correction
    Gain_0 = P0 @ C.T * np.linalg.inv(C @ P0 @ C.T + R)
    x0 = A_discrete @ x0 + B_discrete @ u
    y = C @ x0 + w_y
    y_measured.append(y[0])
    x0_observer = x0_observer + Gain_0 @ (y - C @ x0_observer) + w_x
    y_hat = C @ x0_observer
    x_data.append(x0)
    x_hat_data.append(x0_observer)
    P0 = (np.eye(3) - Gain_0 @ C) @ P0
    
    # Prediction
    x0_observer = A_discrete @ x0_observer + B_discrete @ u
    P0 = A_discrete @ P0 @ A_discrete.T + Q
